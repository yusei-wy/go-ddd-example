# AI プロンプトテンプレート集

## 概要

このドキュメントは、Go DDD プロジェクトでの AI 開発を効率化するためのプロンプトテンプレート集です。

## 基本テンプレート

### プロジェクト情報テンプレート

```
プロジェクト情報:
- 言語: Go 1.21以上
- アーキテクチャ: DDD + CQRS + FSD
- フレームワーク: Echo (Web), GORM (ORM), Testify (Testing)
- データベース: PostgreSQL
- レイヤー構成: Presentation → Application → Domain → Infrastructure

命名規則:
- Go言語公式ガイドライン準拠 (MixedCaps/mixedCaps)
- パッケージ名: 小文字のみ、アンダースコアなし
- ファイル名: snake_case.go

以下のディレクトリ構造に従ってください:
feature/<domain>/
├── domain/         # ビジネスロジック
├── usecase/        # アプリケーションロジック
├── infra/          # インフラストラクチャ
└── handler.go      # プレゼンテーション
```

## ドメイン層開発テンプレート

### エンティティ作成プロンプト

```
# エンティティ作成プロンプト

以下の要件でエンティティを作成してください:

ドメイン: [ドメイン名]
エンティティ名: [エンティティ名]
属性:
- [属性1]: [型/説明]
- [属性2]: [型/説明]
- [属性3]: [型/説明]

ビジネスルール:
- [ルール1]
- [ルール2]
- [ルール3]

要件:
1. 不変のIDを持つエンティティとして実装
2. 属性は値オブジェクトを使用
3. ビジネスルールをメソッドとして実装
4. 適切なバリデーションを含める
5. コンストラクタでの初期化検証
6. ゲッターメソッドの提供

出力ファイル: feature/[ドメイン]/domain/model/[エンティティ名].go

例:
ドメイン: user
エンティティ名: User
属性:
- ID: ユーザーの一意識別子
- Name: ユーザー名（1-100文字）
- Email: メールアドレス（ユニーク）
- CreatedAt: 作成日時

ビジネスルール:
- メールアドレスは重複不可
- ユーザー名は空文字不可
- 作成後のIDは変更不可
```

### 値オブジェクト作成プロンプト

```
# 値オブジェクト作成プロンプト

以下の要件で値オブジェクトを作成してください:

値オブジェクト名: [名前]
値の型: [型]
バリデーションルール:
- [ルール1]
- [ルール2]
- [ルール3]

要件:
1. 不変性の保証
2. コンストラクタでのバリデーション
3. Equalsメソッドの実装
4. Stringメソッドの実装
5. 適切なエラーハンドリング
6. カスタムエラー型の使用

出力ファイル: feature/[ドメイン]/domain/model/value_object/[名前].go

例:
値オブジェクト名: Email
値の型: string
バリデーションルール:
- 空文字不可
- メール形式チェック（正規表現）
- 最大長254文字
- 小文字に正規化
```

### ドメインサービス作成プロンプト

```
# ドメインサービス作成プロンプト

以下の要件でドメインサービスを作成してください:

ドメイン: [ドメイン名]
サービス名: [サービス名]
責務: [サービスの責務説明]

ビジネスロジック:
- [ロジック1]
- [ロジック2]
- [ロジック3]

依存関係:
- [依存1]: [説明]
- [依存2]: [説明]

要件:
1. ドメインロジックのみに集中
2. 外部依存はインターフェースを通す
3. ステートレスな実装
4. 適切なエラーハンドリング
5. ユニットテストも同時に作成

出力ファイル: feature/[ドメイン]/domain/service.go

例:
ドメイン: user
サービス名: UserDomainService
責務: ユーザー関連のビジネスルール実行

ビジネスロジック:
- メールアドレス重複チェック
- ユーザー作成時のビジネスルール検証
- パスワード強度チェック

依存関係:
- UserRepository: ユーザーデータアクセス
```

## アプリケーション層開発テンプレート

### ユースケース作成プロンプト

```
# ユースケース作成プロンプト

以下の要件でユースケースを作成してください:

ユースケース名: [ユースケース名]
アクション: [Create/Update/Delete/Find]
エンティティ: [対象エンティティ]

入力データ:
- [フィールド1]: [型/説明]
- [フィールド2]: [型/説明]
- [フィールド3]: [型/説明]

出力データ:
- [フィールド1]: [型/説明]
- [フィールド2]: [型/説明]

ビジネスルール:
- [ルール1]
- [ルール2]
- [ルール3]

要件:
1. 入力・出力構造体の定義
2. バリデーション実装
3. ドメインサービス・リポジトリの活用
4. 適切なエラーハンドリング
5. トランザクション境界の考慮
6. ユニットテスト・統合テストの作成

出力ファイル: feature/[ドメイン]/usecase/[アクション]_[エンティティ].go

例:
ユースケース名: CreateUserUsecase
アクション: Create
エンティティ: User

入力データ:
- Name: string (ユーザー名)
- Email: string (メールアドレス)
- Password: string (パスワード)

出力データ:
- ID: string (作成されたユーザーID)
- CreatedAt: time.Time (作成日時)

ビジネスルール:
- メールアドレス重複チェック
- パスワード強度検証
- ユーザー名の妥当性チェック
```

### CQRS パターンプロンプト

```
# CQRS実装プロンプト

以下の要件でCQRSパターンを実装してください:

ドメイン: [ドメイン名]
エンティティ: [エンティティ名]

コマンド側（書き込み）:
操作: [Create/Update/Delete]
入力フィールド:
- [フィールド1]: [型/説明]
- [フィールド2]: [型/説明]

クエリ側（読み取り）:
クエリ種別: [FindById/FindByEmail/List等]
検索条件:
- [条件1]: [型/説明]
- [条件2]: [型/説明]

出力形式:
- [フィールド1]: [型/説明]
- [フィールド2]: [型/説明]

要件:
1. コマンドモデルとクエリモデルの分離
2. それぞれ専用のユースケース作成
3. 適切な責務分離
4. 両方のテスト作成

出力ファイル:
- feature/[ドメイン]/domain/model/command/[操作]_[エンティティ]_command.go
- feature/[ドメイン]/domain/model/query/[エンティティ]_[クエリ種別]_query.go
- feature/[ドメイン]/usecase/[操作]_[エンティティ].go
- feature/[ドメイン]/usecase/[クエリ種別]_[エンティティ].go
```

## インフラ層開発テンプレート

### リポジトリ実装プロンプト

```
# リポジトリ実装プロンプト

以下の要件でリポジトリを実装してください:

エンティティ: [エンティティ名]
データベース: PostgreSQL
ORM: GORM

CRUD操作:
- Create: [説明]
- Read: [検索条件]
- Update: [更新条件]
- Delete: [削除条件]

インデックス要件:
- [フィールド1]: [ユニーク/複合/等]
- [フィールド2]: [ユニーク/複合/等]

要件:
1. インターフェースの実装
2. データベースモデルの定義
3. エンティティとDBモデル間の変換
4. 適切なエラーハンドリング
5. トランザクション対応
6. 統合テストの作成

出力ファイル:
- feature/[ドメイン]/domain/repository.go (インターフェース)
- feature/[ドメイン]/infra/model.go (DBモデル)
- feature/[ドメイン]/infra/psql_repository.go (実装)
- feature/[ドメイン]/infra/psql_repository_test.go (テスト)

例:
エンティティ: User
CRUD操作:
- Create: 新規ユーザー作成
- Read: ID検索、メール検索、一覧取得
- Update: ユーザー情報更新
- Delete: ユーザー削除

インデックス要件:
- email: ユニークインデックス
- created_at: 範囲検索用インデックス
```

### データベースマイグレーションプロンプト

```
# マイグレーション作成プロンプト

以下の要件でデータベースマイグレーションを作成してください:

テーブル名: [テーブル名]
操作: [CREATE/ALTER/DROP]

フィールド定義:
- [フィールド1]: [型] [制約] [説明]
- [フィールド2]: [型] [制約] [説明]
- [フィールド3]: [型] [制約] [説明]

インデックス:
- [インデックス1]: [フィールド] [ユニーク/複合]
- [インデックス2]: [フィールド] [ユニーク/複合]

外部キー:
- [FK1]: [参照テーブル.フィールド]
- [FK2]: [参照テーブル.フィールド]

要件:
1. UP/DOWNマイグレーションの作成
2. 適切な制約設定
3. インデックス定義
4. 外部キー制約
5. データ型の最適化

出力ファイル: db/migrations/[YYYYMMDDHHMMSS]_[操作]_[テーブル名].sql

例:
テーブル名: users
操作: CREATE

フィールド定義:
- id: UUID PRIMARY KEY
- name: VARCHAR(100) NOT NULL
- email: VARCHAR(254) UNIQUE NOT NULL
- created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
- updated_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP

インデックス:
- idx_users_email: email (ユニーク)
- idx_users_created_at: created_at
```

## プレゼンテーション層開発テンプレート

### ハンドラー作成プロンプト

```
# ハンドラー作成プロンプト

以下の要件でHTTPハンドラーを作成してください:

エンドポイント: [HTTPメソッド] [パス]
ハンドラー名: [ハンドラー名]
ユースケース: [対応するユースケース]

リクエスト形式:
- [フィールド1]: [型] [バリデーション] [説明]
- [フィールド2]: [型] [バリデーション] [説明]
- [フィールド3]: [型] [バリデーション] [説明]

レスポンス形式:
- [フィールド1]: [型] [説明]
- [フィールド2]: [型] [説明]

エラーレスポンス:
- [エラー1]: [HTTPステータス] [説明]
- [エラー2]: [HTTPステータス] [説明]

要件:
1. 適切なHTTPステータスコード
2. リクエストバリデーション
3. エラーハンドリング
4. レスポンス形式の統一
5. E2Eテストの作成

出力ファイル: feature/[ドメイン]/handler.go

例:
エンドポイント: POST /users
ハンドラー名: CreateUser
ユースケース: CreateUserUsecase

リクエスト形式:
- name: string required min=1,max=100 (ユーザー名)
- email: string required email (メールアドレス)
- password: string required min=8 (パスワード)

レスポンス形式:
- id: string (作成されたユーザーID)
- created_at: string (作成日時)

エラーレスポンス:
- バリデーションエラー: 400 Bad Request
- メール重複: 409 Conflict
- サーバーエラー: 500 Internal Server Error
```

### API設計プロンプト

```
# API設計プロンプト

以下の要件でRESTful APIを設計してください:

リソース: [リソース名]
基本URL: /api/v1/[リソース名]

エンドポイント一覧:
- [操作1]: [HTTPメソッド] [パス] [説明]
- [操作2]: [HTTPメソッド] [パス] [説明]
- [操作3]: [HTTPメソッド] [パス] [説明]

共通ヘッダー:
- Authorization: Bearer [JWT]
- Content-Type: application/json
- Accept: application/json

共通エラーレスポンス:
- 400: Bad Request (バリデーションエラー)
- 401: Unauthorized (認証エラー)
- 403: Forbidden (認可エラー)
- 404: Not Found (リソース未発見)
- 409: Conflict (競合エラー)
- 500: Internal Server Error (サーバーエラー)

要件:
1. RESTful設計原則の遵守
2. 適切なHTTPメソッド選択
3. 一貫したURL設計
4. 標準的なステータスコード使用
5. OpenAPI仕様書の作成

出力ファイル:
- docs/api/[リソース名].yaml (OpenAPI仕様)
- feature/[ドメイン]/handler.go (実装)

例:
リソース: users
基本URL: /api/v1/users

エンドポイント一覧:
- ユーザー作成: POST /users
- ユーザー取得: GET /users/{id}
- ユーザー一覧: GET /users
- ユーザー更新: PUT /users/{id}
- ユーザー削除: DELETE /users/{id}
```

## テスト開発テンプレート

### ユニットテストプロンプト

```
# ユニットテスト作成プロンプト

以下の要件でユニットテストを作成してください:

テスト対象: [ファイルパス/関数名]
テスト種別: Unit Test

テストケース:
正常系:
- [ケース1]: [条件] → [期待結果]
- [ケース2]: [条件] → [期待結果]

異常系:
- [ケース1]: [条件] → [期待エラー]
- [ケース2]: [条件] → [期待エラー]

境界値:
- [ケース1]: [境界条件] → [期待結果]
- [ケース2]: [境界条件] → [期待結果]

要件:
1. AAAパターン (Arrange-Act-Assert) の使用
2. 意味のあるテスト名
3. モックオブジェクトの活用
4. エッジケースのカバー
5. 適切なアサーション

出力ファイル: [元ファイル]_test.go

例:
テスト対象: feature/user/domain/model/value_object/email.go/NewEmail

テストケース:
正常系:
- 有効なメールアドレス → Emailオブジェクト生成
- 小文字変換 → 小文字で正規化されたEmail

異常系:
- 空文字 → バリデーションエラー
- 無効な形式 → フォーマットエラー
- 長すぎるメール → 長さエラー

境界値:
- 最大長のメール → 正常作成
- 最大長+1のメール → エラー
```

### 統合テストプロンプト

```
# 統合テスト作成プロンプト

以下の要件で統合テストを作成してください:

テスト対象: [コンポーネント名]
統合範囲: [統合する層・コンポーネント]

テストシナリオ:
- [シナリオ1]: [処理フロー] → [期待結果]
- [シナリオ2]: [処理フロー] → [期待結果]
- [シナリオ3]: [エラーパターン] → [期待エラー]

テストデータ:
- [データ1]: [説明]
- [データ2]: [説明]

外部依存:
- データベース: [テスト用DB]
- 外部API: [モック/スタブ]

要件:
1. 実際のデータベースを使用
2. テストデータのセットアップ/クリーンアップ
3. トランザクション境界のテスト
4. エラーハンドリングのテスト
5. パフォーマンス要件の確認

出力ファイル: [テスト対象]_integration_test.go

例:
テスト対象: CreateUserUsecase
統合範囲: Usecase → Domain Service → Repository → Database

テストシナリオ:
- 正常なユーザー作成 → ユーザー作成成功、DB保存確認
- 重複メールでの作成 → 重複エラー、DB未保存
- 無効データでの作成 → バリデーションエラー

テストデータ:
- 有効ユーザーデータ: 名前、メール、パスワード
- 重複メールデータ: 既存ユーザーと同じメール

外部依存:
- データベース: PostgreSQL テストDB
- 外部API: なし
```

### E2Eテストプロンプト

```
# E2Eテスト作成プロンプト

以下の要件でE2Eテストを作成してください:

テストシナリオ: [ユーザーストーリー]
エンドポイント: [APIエンドポイント一覧]

テストフロー:
1. [ステップ1]: [アクション] → [期待結果]
2. [ステップ2]: [アクション] → [期待結果]
3. [ステップ3]: [アクション] → [期待結果]

テストデータ:
- [データセット1]: [説明]
- [データセット2]: [説明]

検証項目:
- HTTPステータスコード
- レスポンス形式
- データベース状態
- ビジネスルールの動作

要件:
1. 実際のHTTPリクエスト/レスポンス
2. 完全なアプリケーションスタック使用
3. データベースの状態確認
4. 複数ユーザーシナリオ対応
5. 認証/認可のテスト

出力ファイル: feature/[ドメイン]/[機能]_e2e_test.go

例:
テストシナリオ: ユーザー登録から情報更新まで
エンドポイント: 
- POST /users (作成)
- GET /users/{id} (取得)
- PUT /users/{id} (更新)

テストフロー:
1. ユーザー作成リクエスト → 201 Created、ID返却
2. 作成したユーザー情報取得 → 200 OK、正しいデータ
3. ユーザー情報更新 → 200 OK、更新確認

テストデータ:
- 新規ユーザーデータ: 名前、メール、パスワード
- 更新用データ: 新しい名前
```

## デバッグ・トラブルシューティングテンプレート

### エラー解析プロンプト

```
# エラー解析プロンプト

以下のエラーを解析して解決策を提示してください:

エラー内容:
```
[エラーメッセージをここに貼り付け]
```

発生箇所: [ファイル名:行番号]
発生条件: [エラーが発生する条件]

関連コード:
```go
[エラーが発生するコード片]
```

環境情報:
- Go バージョン: [バージョン]
- OS: [OS情報]
- 依存ライブラリ: [関連ライブラリ]

求める情報:
1. エラーの原因分析
2. 具体的な修正方法
3. 再発防止策
4. 関連するベストプラクティス

プロジェクト制約:
- DDDアーキテクチャの維持
- 既存コードとの一貫性保持
- セキュリティ要件の遵守
```

### パフォーマンス最適化プロンプト

```
# パフォーマンス最適化プロンプト

以下のコードのパフォーマンスを最適化してください:

対象コード:
```go
[最適化対象のコード]
```

パフォーマンス問題:
- [問題1]: [具体的な症状]
- [問題2]: [具体的な症状]

パフォーマンス要件:
- レスポンス時間: [目標値]
- スループット: [目標値]
- メモリ使用量: [制限値]

制約条件:
- 機能の変更不可
- 既存APIの互換性維持
- DDDアーキテクチャの維持

求める最適化:
1. ボトルネック特定
2. 最適化実装
3. ベンチマーク測定方法
4. モニタリング指標

プロファイリング結果: [あれば貼り付け]
```

## AI開発効率化テンプレート

### リファクタリングプロンプト

```
# リファクタリングプロンプト

以下のコードをリファクタリングしてください:

対象コード:
```go
[リファクタリング対象のコード]
```

リファクタリング目標:
- [目標1]: [具体的な改善点]
- [目標2]: [具体的な改善点]
- [目標3]: [具体的な改善点]

制約条件:
- 既存の公開APIは変更不可
- 既存のテストは通る必要がある
- DDDパターンの遵守
- パフォーマンスの劣化不可

改善観点:
1. 可読性の向上
2. 保守性の向上
3. テスタビリティの向上
4. DRY原則の適用
5. SOLID原則の適用

出力要求:
- リファクタリング後のコード
- 変更点の説明
- 影響範囲の分析
- テスト修正の必要性
```

### コードレビュープロンプト

```
# コードレビュープロンプト

以下のコードをレビューしてください:

プルリクエスト情報:
- タイトル: [PR タイトル]
- 概要: [変更概要]
- 影響範囲: [影響するコンポーネント]

変更コード:
```go
[レビュー対象のコード]
```

レビュー観点:
1. アーキテクチャ設計 (DDD準拠)
2. コード品質 (命名、構造、可読性)
3. セキュリティ (脆弱性チェック)
4. パフォーマンス (効率性)
5. テスト充足性
6. エラーハンドリング適切性

プロジェクト規約:
- Go言語標準準拠 (MixedCaps/mixedCaps)
- カスタムエラー型使用
- 階層的バリデーション実装
- プリペアドステートメント使用

出力形式:
- ✅ 良い点の指摘
- 🟡 改善提案
- 🔴 必須修正項目
- ❓ 質問・確認事項
```

## 最終更新

- 日付: 2025.05.24
- 更新者: AI Assistant
